{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Home","text":"","path":["Home"],"tags":[]},{"location":"#jakob-stender-guldberg","level":2,"title":"Jakob Stender Guldberg","text":"<p>Software Developer &amp; Data Platform Engineer</p> <p>Download CV</p>","path":["Home"],"tags":[]},{"location":"#get-in-touch","level":2,"title":"Get in Touch","text":"<p>Feel free to reach out if you want to collaborate on a project.</p> <p> Email  LinkedIn</p>","path":["Home"],"tags":[]},{"location":"#about-me","level":2,"title":"About Me","text":"<p>A passionate and experienced software developer with a knack for creating simple and usable solutions.</p> <p>I specialize in data pipelines, process automation, and infrastructure modernization, always seeking the newest technologies to deliver better solutions, faster.</p>","path":["Home"],"tags":[]},{"location":"#core-competencies","level":2,"title":"Core Competencies","text":"","path":["Home"],"tags":[]},{"location":"#python","level":3,"title":"Python","text":"<p>End-to-end development across the full stack: backend (Django, FastAPI), data analysis (Polars, Spark), workflow automation, CLI tools, and ML integration.</p>","path":["Home"],"tags":[]},{"location":"#workflow-orchestration","level":3,"title":"Workflow Orchestration","text":"<p>Production experience with Prefect, Airflow, and Snakemake for building scalable data pipelines. Designing workflows that handle complex dependencies and large-scale data processing.</p>","path":["Home"],"tags":[]},{"location":"#hpc-infrastructure","level":3,"title":"HPC &amp; Infrastructure","text":"<p>Provisioning and managing HPC clusters with Slurm via Ansible. Monitoring with Prometheus, Grafana, and Loki. Experience with distributed computing and resource optimization.</p>","path":["Home"],"tags":[]},{"location":"#data-visualization-dashboards","level":3,"title":"Data Visualization &amp; Dashboards","text":"<p>Building intuitive dashboards and internal tools with Streamlit, Dash, and Reflex. Making complex analyses accessible to non-technical stakeholders.</p>","path":["Home"],"tags":[]},{"location":"#reproducibility-devops","level":3,"title":"Reproducibility &amp; DevOps","text":"<p>Docker, Docker Swarm, Nix, and uv for reproducible environments across platforms. CI/CD pipelines with GitHub Actions, GitLab CI, and Jenkins.</p>","path":["Home"],"tags":[]},{"location":"#security-compliance","level":3,"title":"Security &amp; Compliance","text":"<p>Implementing least-privilege access, VPN segmentation, ACL management, and working with sensitive data. Experience with GDPR, NIS2, and follow best practices for healthcare data.</p>","path":["Home"],"tags":[]},{"location":"blog/","level":1,"title":"Blog Posts","text":"<p>These blog posts serve partly as exploration of various tools I find, partly documentation for things I find interesting and think is worth sharing with the world, and lastly to improve my writing, which I have previously found hard to be more... Elaborate.</p>","path":["Blog","Blog Posts"],"tags":[]},{"location":"blog/posts/using-secrets-in-dotenv/","level":1,"title":"Managing Secrets in Dotenv Files with the Keyring","text":"<p>As a first try on writing and article I thought of many topics that could be fun, but starting with something simple, that I actually find myself using more often, might be the better topic to start off with. So here goes nothing!</p>","path":["Blog","Posts","Managing Secrets in Dotenv Files with the Keyring"],"tags":[]},{"location":"blog/posts/using-secrets-in-dotenv/#managing-secrets-in-dotenv-files-with-the-keyring","level":1,"title":"Managing Secrets in Dotenv Files with the Keyring","text":"<p>When developing software, we often fine ourselves relying on <code>.env</code> files to store configuration and secrets. But this common practice has some serious drawbacks as anyone with access to your computer can read these plaintext passwords.</p> <p>The problem gets worse when:</p> <ul> <li>You accidentally commit a <code>.env</code> file to version control</li> <li>You need to share configuration across team members</li> <li>You must rotate compromised keys across multiple projects</li> </ul> <p>A better approach exists: using your system's keyring. Most operating systems include encrypted vaults like GnomeKeyring or KWalletManager that store WiFi passwords and browser logins behind a master password. Many tools for interacting with the keyring exists, but I prefer the simplicity of the cli-tool keyring for programmatic interactions.</p> <p>Install however you like, but for the sake of inclusion, here is one way:</p> <pre><code># Install the keyring tool\nuv tool install keyring\n</code></pre> <p>We can then proceed to look at common <code>.env</code> that looks something like this:</p> <pre><code>foo=1\nbar=2\nDB_PASSWORD=pass123\n</code></pre> <p>Now, with the keyring available to our fingertips, we can store in the keyring like so:</p> <pre><code>keyring --help\nusage: keyring ... [{get,set,...}] [service] [username]\n</code></pre> <p>I have truncated things that are not important, for now, as we are only concerned about settings and getting our secrets. I usually prefer the naming convention for service as the service or project I am working on or using e.g. my-service or name-of-online-service, and then username as a descriptive name for what the secret is used for, e.g. db-admin-pass or api_key. First we add the secret to the keyring:</p> <pre><code>‚ùØ keyring set my-service db-admin-password\nPassword for 'db-admin-password' in 'my-service': *******\n</code></pre> <p>Then proceed to reference it in your <code>.env</code> file:</p> <pre><code>foo=1\nbar=2\nDB_PASSWORD=$(keyring get my-service db-admin-password)\n</code></pre> <p>This approach gives you a few things:</p> <ul> <li>Centralized secret management</li> <li>Easy key rotation (update once, apply everywhere)</li> <li>Shareable configuration without exposing secrets</li> <li>Better security than plaintext files</li> </ul> <p>The keyring acts as a set-and-forget solution that keeps your secrets secure while maintaining the convenience of <code>.env</code> files. Though you still need to source the file to actually get the secret available in the environment.</p> <p>The automation of this will be in the next post, I think.</p>","path":["Blog","Posts","Managing Secrets in Dotenv Files with the Keyring"],"tags":[]}]}